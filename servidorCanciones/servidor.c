/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <time.h>
#include "interface1.h"
#include "interface2.h"
#include "interface3.h"
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <stdbool.h>
#include <dirent.h>

char *nombreNuevo;
char *nombreRuta;
datosCalculados *datosCancion;
nodo_cancion vectorCanciones[5];
int tamano=0;
void enviarArchivoAlServidor(char * nombreArchivo,CLIENT *clnt);

//servidor
int * creararchivo_1_svc(char **argp, struct svc_req *rqstp)
{
	static int  result;
    
	printf("\nInvocando a crear archivo");
    printf("\n");
    
	fopen((*argp ),"w");
   		

	return &result;
}

int *enviararchivo_1_svc(bloque *argp, struct svc_req *rqstp){
	static int  result;
	struct stat sb;
	result=0;
	FILE *file;
	CLIENT *clnt;
	int  *result_1;
	int  *result_2;
	file=fopen((*argp).nombreArchivo,"a");
	if(file==NULL){
		result =1;
	}
	fseek(file,(*argp).dest_offset,SEEK_SET);
	fwrite((*argp).datos.datos_val,1,(*argp).datos.datos_len,file);
	fclose(file);

	if((*argp).dest_offset==0){
		printf("\nPrimer bloque recibido correctamente");
		printf("\n");
	}
	else if((*argp).datos.datos_len<TAM_MAX_BLOQUE_ARCHIVO){
		printf("\nUltimo bloque recibido exitosamente\n");
		if(stat((*argp).nombreArchivo,&sb)==-1){
		perror("stat");
		exit(EXIT_FAILURE);
		}else{	
		printf("total bytes: %lu \n ",sb.st_size);
		}
		//validacion extension
		char *mencion;
		char x='.';
		mencion =strchr((*argp).nombreArchivo,x);
		//guardamos el nombre ne una variable
		char sinextension[30];
		sprintf(sinextension,"%s",(*argp).nombreArchivo);
		//al nombre le cogemos lo que tieneantes del punto osea el nombre de la cacion
		char *nombre=strtok(sinextension,".");
		//guardamos el archivo con el nuevo nombre en una variable
		nombreNuevo=(char*)malloc(30*sizeof(char));
		sprintf(nombreNuevo,"%s_%ld%s",sinextension,sb.st_size,mencion);
		//guardamos la ruta 
		nombreRuta=(char*)malloc(30*sizeof(char));
		sprintf(nombreRuta,"Canciones/%s",nombreNuevo);
		//cambiamos ruta de envio
		if(rename((*argp).nombreArchivo,nombreRuta)==0){
			printf("\nEl archivo se renombro correctamente\n");
		}
		
		//CLIENTE

		printf("\n=======================================");
		printf("\nEnviando copia al servidor de respaldo");
		printf("\n=======================================\n");
		#ifndef	DEBUG	
		clnt = clnt_create ("localhost", programa_compartir_canciones2, programa_compartir_canciones_version_2, "tcp");
		if (clnt == NULL) {
			clnt_pcreateerror ("localhost");
			exit (1);
		}
		#endif	

		result_1 = crearcopiaarchivo_2(&nombreRuta, clnt);
		if (result_1 == (int *) NULL) {
			clnt_perror (clnt, "call failed");
		}else{
			printf("\nArchivo vacio creado en el servidor de respaldo");
			printf("\nProcedimiento a enviar en bloques el archivo");
			enviarArchivoAlServidor(nombreNuevo,clnt);	
			
		}
		printf("\n==========================================");
		printf("\nEnviando notificacion al servidor de logs");
		printf("\n==========================================\n");
		//CLIENTE DE INTERFACE3
		clnt = clnt_create("localhost", programa_calcular_datos, programa_calcular_datos_version3, "tcp");
		if (clnt == NULL) {
			clnt_pcreateerror("localhost");
			exit(1);
		}
		
		result_2 = enviar_notificacion_3(datosCancion, clnt);
		if (result_2 == (int *)NULL) {
			clnt_perror(clnt, "call failed");
		} else printf("\nEl servidor de Logs ha sido notificado correctamente\n\n");

		
		
	}
	
	return &result;
}

bool_t *
registrarcancion_1_svc(nodo_cancion *argp, struct svc_req *rqstp)
{
	static bool_t  result=TRUE;

	//Hora y fecha de registro
		
	time_t t = time(NULL);
  	struct tm tiempoLocal = *localtime(&t);
	datosCancion = (datosCalculados*)malloc(sizeof(struct datosCalculados));
	char fechaHora[70];
	char *formato = "%Y-%m-%d %H:%M:%S";
	int bytesEscritos = strftime(fechaHora, sizeof fechaHora, formato, &tiempoLocal);
     
	printf("\n------Invocando a registrar cancion------");
	printf("\nDatos de la cancion a registrar");
	printf("\nId de la cancion: %d", argp->codigoCancion);
	printf("\nTitulo de la cancion: %s",argp->titulo);
	printf("\nTipo de la cancion: %s",argp->tipo);
	printf("\nTamaÃ±o de la cancion: %d",argp->peso);
	printf("\n-----------------------------------------\n");

	if (bytesEscritos != 0) {
		// Si no hay error, los bytesEscritos no son 0
		strcpy(datosCancion->titulo,fechaHora);
		
	} else {
		printf("\nError formateando fecha");
	}
	int codigo;
	codigo=argp->codigoCancion;
	argp->codigoCancion=codigo;
	strcpy(datosCancion->tipo,argp->tipo);
	datosCancion->peso=argp->peso;
	vectorCanciones[tamano]=*argp;
	tamano++;
	return &result;
}

nodo_cancion * consultarcancion_1_svc(char **argp, struct svc_req *rqstp)
{
	static nodo_cancion result;
	memset(&result, 0, sizeof(nodo_cancion));
	printf("\nInvocando a consultar cancion");
	printf("\nNombre de la cancion a consultar: %s",*argp);
	printf("\n");
	for(int i=0;i<5;i++){
		if(	strcmp((&vectorCanciones[i])->titulo,*argp)==0){
			result=vectorCanciones[i];
			break;
		}
	
	}	return &result;	

}	

void enviarArchivoAlServidor(char * nombreArchivo,CLIENT *clnt){
		
		
		FILE *file;
		if(file=fopen(nombreRuta,"r")){
			bool bandera=TRUE;
			int pos=0,cantidadBloques=0;
			bloque2 objBloque;
			objBloque.nombreArchivo=(char*)malloc(20*sizeof(char));
			strcpy(objBloque.nombreArchivo,nombreArchivo);
			objBloque.datos.datos_val=(char*)malloc(TAM_MAX_BLOQUE_ARCHIVO * sizeof(char));
			do{
				objBloque.datos.datos_len=fread(objBloque.datos.datos_val,1,TAM_MAX_BLOQUE_ARCHIVO,file);
				objBloque.dest_offset=pos;
				pos=pos+objBloque.datos.datos_len;
				int *resultado=enviarcopiaarchivo_2(&objBloque,clnt);
				if(resultado==(int*) NULL){
					clnt_perror(clnt,"call failed");
					bandera=FALSE;
				}
				else{
					cantidadBloques++;
				}

			} while(objBloque.datos.datos_len==TAM_MAX_BLOQUE_ARCHIVO);
			free(objBloque.datos.datos_val);
			fclose(file);
			if(bandera==TRUE){
				printf("\ncancion enviada exitosamente a partir de %d bloques\n",cantidadBloques);

			}else{
				printf("\nError al enviar la cancion");
			}
		}else{
			printf("\nEl archivo no existe\n");
			exit(1);
		}	
		

	
	
}

